---  -*- maude-command-options: ("-no-wrap" "-ansi-color" "-no-prelude") -*- 
set show advisories off .

load prelude.maude

fmod VAR is
    including QID .
    sort Var .
    subsort Qid < Var .
endfm
    
view Var from TRIV to VAR is
    sort Elt to Var .
endv

fmod EXPR is
    pr VAR .
    pr INT .
    pr BOOL .

    sorts Expr .
    subsort Var < Expr .
    subsort Int < Expr .
    subsort Bool < Expr .

    op _+_ : Expr Expr -> Expr [ditto] .
    op _and_ : Expr Expr -> Expr [ditto] .
    op _=:=_ : Expr Expr -> Bool [prec 25] .
endfm

fmod SYMEXPR is
    pr INT .
    pr BOOL .

    sorts LInt LBool SymBool SymInt SymExpr .
    subsorts LBool < SymBool .
    subsorts LInt < SymInt .
    subsorts SymInt SymBool < SymExpr .

    op x(_): Nat -> LInt [ctor] .
    op b(_): Bool -> LBool [ctor] .
    op int _ : Int -> SymInt [ctor] .
    op bool _ : Bool -> SymBool [ctor] .

    op _+_ : SymInt SymInt -> SymInt [prec 20 assoc comm] .
    op _and_ : SymBool SymBool -> SymBool [prec 20 assoc comm] .
    op _=:=_ : SymExpr SymExpr -> SymBool [prec 25] .
endfm

view SymExpr from TRIV to SYMEXPR is
    sort Elt to SymExpr .
endv

fmod STATEMENTS is
    including VAR .
    including EXPR .

    sorts Statement Statements .
    subsort Statement < Statements .

    op _:=_ : Var Expr -> Statement [ctor] .
    op skip : -> Statement [ctor] .
    op if (_) { _ } else { _ } : Expr Statements Statements -> Statement [ctor] .
    op _;_ : Statements Statements -> Statements [ctor assoc id: skip prec 100] .
endfm

fmod THREAD is
    including NAT .
    including STATEMENTS .

    sort Thread .
    sort ThreadId .
    subsort Nat < ThreadId .

    op idle : -> Thread [ctor] .
    op <_|_> : ThreadId Statements -> Thread [ctor] .
endfm

view Thread from TRIV to THREAD is
    sort Elt to Thread .
endv

fmod SYMPATH is
    sort SymPath .
    op epsilon : -> SymPath [ctor] .
    op _._ : SymPath SymPath -> SymPath [ctor assoc id: epsilon] .
endfm

fmod EVAL is
    including VAR .
    including EXPR .
    including SYMEXPR .
    including MAP{Var, SymExpr} .

    sort Substitution .
    subsort Map{Var, SymExpr} < Substitution .

    var M : Substitution .
    var N : Int .
    var B : Bool .
    var V : Var .
    vars E1 E2 : Expr .

    op eval : Substitution Expr -> SymExpr .
    eq eval(M, N) = int N .
    eq eval(M, B) = bool B .
    eq eval(M, V) = M[V] .
    eq eval(M, E1 + E2) = eval(M, E1) + eval(M, E2) .
    eq eval(M, E1 and E2) = eval(M, E1) and eval(M, E2) .
    eq eval(M, E1 =:= E2) = eval(M, E1) =:= eval(M, E2) .
endfm

fmod SEARCH-STATE is
    including EVAL .
    including SYMPATH .
    including SET{Thread} .

    sorts SearchState Pool NePool .
    subsort Set{Thread} < Pool .
    subsort NeSet{Thread} < NePool .

    op (|_,_,_,_|) : Thread Substitution SymPath Pool -> SearchState
        [ctor format (n d n s n s n s d n)] .
endfm

mod SEMANTICS is
    including CONFIGURATION .
    including SEARCH-STATE .

    subsort SearchState < Configuration .

    vars Sigma Sigma' : Substitution .
    vars V : Var .
    vars E : Expr .
    vars Se : SymExpr .
    vars P P' : Pool .
    vars NP : NePool .
    vars Ss Ss' Ss'' : Statements .
    vars T T' : Thread .
    vars I I' : ThreadId .
    vars Sp Sp' : SymPath .

    op schedules : Pool SearchState -> Configuration .
    eq schedules(empty, (| idle, Sigma, Sp, P' |)) = none .
    eq schedules((T, P), (| idle, Sigma, Sp, P' |)) =
        (| T, Sigma, Sp, P' \ T |) schedules(P, (| idle, Sigma, Sp, P' |)) [owise] .

    crl [Assignment] :
        (| < I | V := E ; Ss >, Sigma, Sp, P |)
    =>
        (| idle, insert(V, Se, Sigma), Sp, (P, < I | Ss >) |)
      if Se := eval(Sigma, E) .

    rl [Schedule] :
        (| idle, Sigma, Sp, NP |)
      =>
        schedules(NP, (| idle, Sigma, Sp, NP |)) .

    --- TODO: Fix sympath
    rl [Cond] :
        (| < I | if (E) { Ss } else { Ss' } ; Ss'' >, Sigma, Sp, P |)
        =>
          (| idle, Sigma, Sp, (P, < I | Ss ; Ss'' > ) |)
          (| idle, Sigma, Sp, (P, < I | Ss' ; Ss'' > ) |) .

    rl [Termination] :
        (| < I | skip >, Sigma, Sp, P |)
      =>
        (| idle, Sigma, Sp, P |) .
endm

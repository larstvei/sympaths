load sympaths.maude
load dynamic.maude

mod TEST is
    including SEMANTICS .
    including DYNAMIC-PROVER .

    vars Sigma Sigma' : Substitution .
    vars B : Nat .
    vars V : Var .
    vars Vs : Vars .
    vars E : Expr .
    vars Ev1 Ev2 : Event .
    vars Se : SymExpr .
    vars L : List{Nat} .
    vars N : Int .
    vars P P' : Pool .
    vars NP NP' : NePool .
    vars Ss Ss' Ss'' : Statements .
    vars T T' : Thread .
    vars I I' : ThreadId .
    vars Sp Sp' : SymPath .
    vars S : SearchState .
    vars C : Configuration .

    op varsof : Pool -> Vars .
    eq varsof(empty) = empty .
    eq varsof((< I | Ss >, P)) = varsof(Ss), varsof(P) .

    op varsof : Statements -> Vars .
    eq varsof(skip) = empty .
    eq varsof((V := E ; Ss)) = V, vars(E), varsof(Ss) .
    eq varsof((if (E) { Ss } else { Ss' } ; Ss'')) = vars(E), varsof((Ss ; Ss' ; Ss'')) .
    eq varsof((while (E) { Ss } ; Ss')) = vars(E), varsof((Ss ; Ss')) .
    eq varsof((while (E)[ B ] { Ss } ; Ss')) = vars(E), varsof((Ss ; Ss')) .

    op sigma : Vars -> Substitution .
    eq sigma(Vs) = sigma(Vs, 0) .

    op sigma : Vars Nat -> Substitution .
    eq sigma(empty, N) = empty .
    eq sigma((V, Vs), N) = V |-> x(N), sigma(Vs, s N) .

    op count : Configuration -> Nat .
    eq count(none) = 0 .
    eq count(S C) = s count(C) .

    op init : Pool -> Configuration .
    eq init(P) = init(P, sigma(varsof(P))) .

    op init : Pool Substitution -> Configuration .
    eq init(P, Sigma) = [ 1 ] (| idle, Sigma, epsilon, P |) .
endm

rew init((< 0 | skip >, < 1 | skip >, < 2 | skip >)) .
rew init(< I | if ('x =:= 1) { 'x := 2 } else { 'x := 'y } >) .
rew init((< 0 | 'y := 'x >, < 1 | 'z := 'x >, < 2 | 'x := 2 >)) .

rew init((< 0 | while ('y =:= 'x)[2] { 'y := 'y + 1 } >,
          < 1 | 'z := 'x >,
          < 2 | 'x := 2 > )) .

--- DL

rew
Gamma, epsilon ==>
('x |-> x(0), 'y |-> x(1), 'z |-> x(2))
[ idle, (< 0 | 'y := 'x >, < 1 | 'z := 'x >, < 2 | 'x := 2 > ) ]
Psy
.

--- Frank test 1
rew init((< 0 | 'x := 0 >,
          < 1 | 'y := 0 >,
          < 2 | if ('x =:= 'y) { 'y := 1 } else { 'y := 2 } > )) .

--- Frank test 2
--- T1:x=0
--- T2:y=0
--- T3if x=1 and y=1 then z=1
--- elif x=1 and y=0 then z=2
--- elif x=0 and y=1 then z=3
--- else z=3
--- fi

rew
init((< 0 | 'x := 0 >,
      < 1 | 'y := 0 >,
      < 2 | if ('x =:= 1 and 'y =:= 1) {
              'z := 1
                } else {
              if ('x =:= 1 and 'y =:= 0) {
                'z := 2
                  } else {
                if ('x =:= 0 and 'y =:= 1) {
                  'z := 3
                    } else {
                  'z := 4
                    }
              }
            }
      > )) .

